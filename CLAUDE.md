# Fusain Protocol Library - AI Assistant Guide

> **Note:** This file documents the fusain module specifically.
> Always read the [Thermoquad Organization CLAUDE.md](../../../CLAUDE.md) first
> for organization-wide structure and conventions.

> **Also known as:** "C Fusain" — the C implementation of the Fusain protocol.

## Module Overview

**fusain** is a platform-independent C library that implements the Fusain protocol. It provides CRC-16-CCITT calculation, packet encoding with byte stuffing, and stateful packet decoding for reliable communication.

**Key Features:**
- Pure C implementation with zero dependencies beyond standard C library
- Platform-agnostic - works on embedded systems and host applications
- Thread-safe encoder (stateless)
- Efficient stateful decoder for byte-by-byte processing
- CRC-16-CCITT error detection
- Byte stuffing for reliable framing

**License:** Apache-2.0
**Copyright:** 2025 Kaz Walker, Thermoquad

---

## Architecture

### Protocol Design

The Fusain protocol uses a binary packet format with CBOR-encoded payloads:

```
[START][LENGTH][ADDRESS][CBOR_PAYLOAD][CRC_HIGH][CRC_LOW][END]
```

- **START byte:** `0x7E` - Packet start marker
- **LENGTH:** 1 byte - CBOR payload length (0-114)
- **ADDRESS:** 8 bytes - Device address (little-endian)
- **CBOR_PAYLOAD:** 0-114 bytes - CBOR array `[msg_type, payload_map]` or `[msg_type, nil]`
- **CRC:** 2 bytes - CRC-16-CCITT over LENGTH + ADDRESS + CBOR_PAYLOAD (big-endian)
- **END byte:** `0x7F` - Packet end marker

**CBOR Format:** Message type is embedded in the CBOR payload as the first element of a 2-element array. The second element is either a CBOR map with payload fields or CBOR nil for empty payloads.

**Packet Size:** 13 bytes framing overhead + CBOR payload = 13-127 bytes total.

### Byte Stuffing

The protocol uses byte stuffing to ensure framing bytes don't appear in the data:

- **Escape byte:** `0x7D`
- **Escape XOR:** `0x20`

Any occurrence of START (0x7E), END (0x7F), or ESC (0x7D) bytes in the data is escaped:
1. Replace byte with ESC (0x7D)
2. Follow with byte XOR 0x20

**Example:**
- Original: `0x7E` → Encoded: `0x7D 0x5E`
- Original: `0x7F` → Encoded: `0x7D 0x5F`
- Original: `0x7D` → Encoded: `0x7D 0x5D`

### CRC Calculation

**Algorithm:** CRC-16-CCITT
- **Polynomial:** 0x1021
- **Initial value:** 0xFFFF
- **Coverage:** LENGTH + ADDRESS + CBOR_PAYLOAD (9 bytes header + CBOR data, excludes framing bytes)
- **Byte order:** Big-endian in packet

The CRC is calculated over the unstuffed data and then the CRC bytes themselves are subject to byte stuffing.

### CBOR Implementation

The library uses CBOR (Concise Binary Object Representation, RFC 8949) for payload encoding, with code generated by zcbor from a CDDL schema.

**Schema Location:** `origin/documentation/source/specifications/fusain/fusain.cddl`

**CBOR Message Structure:**
- Empty payloads: `[msg_type, nil]` encoded as `0x82 <type> 0xF6`
- Payloads with data: `[msg_type, {key: value, ...}]`

**Generated Code:**

The code includes headers from `include/fusain/generated/`:
- `cbor_decode.h` - CBOR decoding function declarations
- `cbor_encode.h` - CBOR encoding function declarations
- `cbor_types.h` - Payload structure definitions

Source files are in `src/generated/`:
- `cbor_decode.c` - CBOR decoding functions
- `cbor_encode.c` - CBOR encoding functions

**CBOR Code Generation:**

When the CDDL schema changes, regenerate CBOR code with:

```bash
task zcbor-generate
```

This task automatically:
1. Generates CBOR code from the CDDL schema
2. Renames files from `fusain_cbor_*` to `cbor_*` prefix
3. Moves headers to `include/fusain/generated/`
4. Fixes include paths in generated files
5. Runs tests to verify the generated code compiles and works correctly

**After regenerating CBOR code:** If the CDDL schema changed field names or types,
you may need to compare the new `cbor_types.h` against the old version and update
`src/fusain.c` to use any new field names from the regenerated types.

---

## Message Types

### Configuration Commands (Controller → Appliance) 0x10-0x1F

| Type | Value | Payload | Description |
|------|-------|---------|-------------|
| `FUSAIN_MSG_MOTOR_CONFIG` | 0x10 | `fusain_cmd_motor_config_t` | Configure motor controller parameters |
| `FUSAIN_MSG_PUMP_CONFIG` | 0x11 | `fusain_cmd_pump_config_t` | Configure pump controller parameters |
| `FUSAIN_MSG_TEMP_CONFIG` | 0x12 | `fusain_cmd_temp_config_t` | Configure temperature controller parameters |
| `FUSAIN_MSG_GLOW_CONFIG` | 0x13 | `fusain_cmd_glow_config_t` | Configure glow plug parameters |
| `FUSAIN_MSG_DATA_SUBSCRIPTION` | 0x14 | `fusain_cmd_data_subscription_t` | Subscribe to data from appliance |
| `FUSAIN_MSG_DATA_UNSUBSCRIBE` | 0x15 | `fusain_cmd_data_unsubscribe_t` | Unsubscribe from appliance data |
| `FUSAIN_MSG_TELEMETRY_CONFIG` | 0x16 | `fusain_cmd_telemetry_config_t` | Enable/disable telemetry broadcasts |
| `FUSAIN_MSG_TIMEOUT_CONFIG` | 0x17 | `fusain_cmd_timeout_config_t` | Configure communication timeout |
| `FUSAIN_MSG_DISCOVERY_REQUEST` | 0x1F | None | Request device capabilities |

### Control Commands (Controller → Appliance) 0x20-0x2F

| Type | Value | Payload | Description |
|------|-------|---------|-------------|
| `FUSAIN_MSG_STATE_COMMAND` | 0x20 | `fusain_cmd_set_mode_t` | Set system mode/state |
| `FUSAIN_MSG_MOTOR_COMMAND` | 0x21 | `fusain_cmd_set_target_rpm_t` | Set motor RPM |
| `FUSAIN_MSG_PUMP_COMMAND` | 0x22 | `fusain_cmd_set_pump_rate_t` | Set pump rate |
| `FUSAIN_MSG_GLOW_COMMAND` | 0x23 | `fusain_cmd_glow_t` | Control glow plug |
| `FUSAIN_MSG_TEMP_COMMAND` | 0x24 | `fusain_cmd_temp_command_t` | Temperature controller control |
| `FUSAIN_MSG_SEND_TELEMETRY` | 0x25 | `fusain_cmd_send_telemetry_t` | Request telemetry data (polling mode) |
| `FUSAIN_MSG_PING_REQUEST` | 0x2F | None | Heartbeat/connectivity check |

### Telemetry Data (Appliance → Controller) 0x30-0x3F

| Type | Value | Payload | Description |
|------|-------|---------|-------------|
| `FUSAIN_MSG_STATE_DATA` | 0x30 | `fusain_data_state_t` | System state and status |
| `FUSAIN_MSG_MOTOR_DATA` | 0x31 | `fusain_data_motor_t` | Motor telemetry |
| `FUSAIN_MSG_PUMP_DATA` | 0x32 | `fusain_data_pump_t` | Pump status and events |
| `FUSAIN_MSG_GLOW_DATA` | 0x33 | `fusain_data_glow_t` | Glow plug status |
| `FUSAIN_MSG_TEMP_DATA` | 0x34 | `fusain_data_temperature_t` | Temperature readings |
| `FUSAIN_MSG_DEVICE_ANNOUNCE` | 0x35 | `fusain_data_device_announce_t` | Device capabilities announcement |
| `FUSAIN_MSG_PING_RESPONSE` | 0x3F | `fusain_data_ping_response_t` | Heartbeat response |

### Error Messages (Bidirectional) 0xE0-0xEF

| Type | Value | Payload | Description |
|------|-------|---------|-------------|
| `FUSAIN_MSG_ERROR_INVALID_CMD` | 0xE0 | `fusain_error_invalid_cmd_t` | Command validation failed |
| `FUSAIN_MSG_ERROR_STATE_REJECT` | 0xE1 | `fusain_error_state_reject_t` | Command rejected by state machine |

---

## File Structure

```
fusain/
├── CLAUDE.md               # This file
├── README.md               # User documentation
├── LICENSE.md              # Apache-2.0 license
├── Taskfile.dist.yml       # Task runner (Zephyr + standalone tasks)
├── CMakeLists.txt          # Dual-mode build (Zephyr module + standalone CMake)
├── Kconfig                 # Zephyr configuration options
├── west.yml                # West manifest for CI (Zephyr + zcbor dependencies)
├── Dockerfile              # CI container definition
├── .zephyr-sdk-version     # Zephyr SDK version for CI
├── .github/
│   └── workflows/
│       └── ci.yml          # GitHub Actions CI workflow
├── git-hooks/
│   └── pre-commit          # Pre-commit hook (install with task install-git-hooks)
├── zephyr/
│   └── module.yml          # Zephyr module metadata
├── cmake/
│   └── fusainConfig.cmake.in  # CMake package config template (for find_package)
├── include/
│   └── fusain/
│       ├── fusain.h              # Public API header
│       └── generated/            # zcbor-generated headers
│           ├── cbor_types.h      # CBOR type definitions
│           ├── cbor_decode.h     # Decode function declarations
│           └── cbor_encode.h     # Encode function declarations
├── src/
│   ├── fusain.c              # Protocol implementation
│   ├── fusain_net_buf.c      # Zephyr net_buf API (optional)
│   └── generated/            # zcbor-generated sources
│       ├── cbor_decode.c     # CBOR decoding functions
│       └── cbor_encode.c     # CBOR encoding functions
└── tests/
    ├── src/                # Zephyr test sources (ztest-based)
    │   ├── main.c
    │   ├── test_crc.c
    │   ├── test_encoding.c
    │   ├── test_decoding.c
    │   ├── test_packet_creation.c
    │   └── test_fuzz.c
    └── standalone/         # Standalone test infrastructure
        ├── CMakeLists.txt  # Standalone test build
        ├── main.c          # Test runner with auto-registration
        └── zephyr/
            └── ztest.h     # Ztest compatibility layer for standalone builds
```

---

## API Reference

### Core Functions

#### CRC Calculation

```c
uint16_t fusain_crc16(const uint8_t* data, size_t length);
```

Calculates CRC-16-CCITT over the provided data.

**Parameters:**
- `data` - Pointer to data buffer
- `length` - Length of data in bytes

**Returns:** CRC-16 value

**Thread Safety:** Thread-safe (pure function)

---

#### Packet Encoding

```c
int fusain_encode_packet(const fusain_packet_t* packet,
                         uint8_t* buffer,
                         size_t buffer_size);
```

Encodes a packet structure into a byte stream with byte stuffing and CRC.

**Parameters:**
- `packet` - Packet structure to encode
- `buffer` - Output buffer for encoded bytes
- `buffer_size` - Size of output buffer (must be at least `FUSAIN_MAX_PACKET_SIZE * 2`)

**Returns:**
- Number of bytes written on success
- Negative error code on failure

**Thread Safety:** Thread-safe (stateless)

**Error Codes:**
- `-1` - Invalid parameters
- `-2` - Invalid payload length
- `-3` to `-9` - Buffer overflow at various stages

---

#### Packet Decoding

```c
fusain_decode_result_t fusain_decode_byte(uint8_t rx_byte,
                                          fusain_packet_t* packet,
                                          uint8_t* state,
                                          uint8_t* buffer,
                                          size_t* buffer_index,
                                          bool* escape_next);
```

Decodes received bytes into a packet structure. Call repeatedly as bytes are received.

**Parameters:**
- `rx_byte` - Received byte to process
- `packet` - Output packet structure (valid only when result is `FUSAIN_DECODE_OK`)
- `state` - Decoder state (initialize to 0, maintain between calls)
- `buffer` - Internal decode buffer (must be `FUSAIN_MAX_PACKET_SIZE` bytes)
- `buffer_index` - Current buffer index (initialize to 0, maintain between calls)
- `escape_next` - Escape flag (initialize to false, maintain between calls)

**Returns:**
- `FUSAIN_DECODE_OK` - Packet complete and valid (check `packet`)
- `FUSAIN_DECODE_INCOMPLETE` - Need more bytes
- `FUSAIN_DECODE_INVALID_START` - Invalid start/end byte
- `FUSAIN_DECODE_INVALID_CRC` - CRC mismatch
- `FUSAIN_DECODE_INVALID_LENGTH` - Invalid payload length
- `FUSAIN_DECODE_BUFFER_OVERFLOW` - Buffer overflow

**Thread Safety:** NOT thread-safe (requires separate state per connection)

**State Machine:**
The decoder maintains internal state across calls:
1. IDLE - Waiting for START byte
2. LENGTH - Reading payload length
3. TYPE - Reading message type
4. PAYLOAD - Reading payload bytes
5. CRC1 - Reading CRC high byte
6. CRC2 - Reading CRC low byte
7. END - Validating END byte and CRC

---

#### Decoder Reset

```c
void fusain_reset_decoder(uint8_t* state,
                          size_t* buffer_index,
                          bool* escape_next);
```

Resets the decoder state (use after errors or to start fresh).

**Parameters:**
- `state` - Decoder state to reset
- `buffer_index` - Buffer index to reset
- `escape_next` - Escape flag to reset

**Thread Safety:** Thread-safe

---

### Helper Functions

The library provides convenience functions for creating common message types:

#### Command Helpers

```c
void fusain_create_state_command(fusain_packet_t* packet,
                                 uint64_t address,
                                 fusain_mode_t mode,
                                 int32_t argument);

void fusain_create_set_pump_rate(fusain_packet_t* packet,
                                 uint32_t rate_ms);

void fusain_create_set_target_rpm(fusain_packet_t* packet,
                                  uint32_t target_rpm);

void fusain_create_ping_request(fusain_packet_t* packet);

void fusain_create_set_timeout_config(fusain_packet_t* packet,
                                      bool enabled,
                                      uint32_t timeout_ms);

void fusain_create_emergency_stop(fusain_packet_t* packet);
```

#### Data Helpers

```c
void fusain_create_state_data(fusain_packet_t* packet, uint64_t address,
                              uint32_t error, int32_t code,
                              fusain_state_t state, uint32_t timestamp);

void fusain_create_ping_response(fusain_packet_t* packet, uint64_t address,
                                 uint32_t uptime_ms);

void fusain_create_device_announce(fusain_packet_t* packet, uint64_t address,
                                   uint8_t motor_count, uint8_t thermometer_count,
                                   uint8_t pump_count, uint8_t glow_count);

void fusain_create_motor_data(fusain_packet_t* packet, uint64_t address,
                              uint8_t motor, uint32_t timestamp, uint32_t rpm,
                              uint32_t target, uint32_t pwm_duty);

void fusain_create_pump_data(fusain_packet_t* packet, uint64_t address,
                             uint8_t pump, uint32_t timestamp, uint32_t pulses);

void fusain_create_glow_data(fusain_packet_t* packet, uint64_t address,
                             uint8_t glow, uint32_t timestamp, bool active,
                             uint32_t elapsed_ms);

void fusain_create_temp_data(fusain_packet_t* packet, uint64_t address,
                             uint8_t thermometer, uint32_t timestamp, double reading,
                             bool temperature_rpm_control, int32_t watched_motor,
                             double target_temperature);
```

#### Error Helpers

```c
void fusain_create_error_invalid_cmd(fusain_packet_t* packet, uint64_t address,
                                     uint8_t rejected_type, const char* reason);

void fusain_create_error_state_reject(fusain_packet_t* packet, uint64_t address,
                                      uint8_t rejected_type, uint8_t current_state,
                                      const char* reason);
```

**Note:** All helpers populate the `packet` structure. You must still call `fusain_encode_packet()` to serialize for transmission.

---

#### Net Buffer API (Zephyr Only)

When `CONFIG_FUSAIN_NET_BUF=y` (default when FUSAIN is enabled), the library provides
a net_buf wrapper for convenient packet routing:

```c
#include <zephyr/net/buf.h>
#include <fusain/fusain.h>

struct net_buf *fusain_decode_byte_to_net_buf(uint8_t byte,
                                              struct net_buf_pool *pool,
                                              fusain_decoder_t *decoder);

static inline fusain_packet_t *fusain_packet_from_buf(struct net_buf *buf);
```

**Usage Example:**

```c
NET_BUF_POOL_DEFINE(fusain_pool, 8, sizeof(fusain_packet_t), 0, NULL);

static fusain_decoder_t decoder;

void rx_handler(uint8_t byte) {
    struct net_buf *buf = fusain_decode_byte_to_net_buf(byte,
                                                        &fusain_pool,
                                                        &decoder);
    if (buf != NULL) {
        fusain_packet_t *packet = fusain_packet_from_buf(buf);
        // Process or route packet...
        net_buf_unref(buf);
    }
}
```

This API enables zero-copy routing to Bluetooth, TCP, or other Zephyr subsystems.

---

## Usage Examples

### Basic Encoding

```c
#include <fusain/fusain.h>

// Create a ping request
fusain_packet_t packet;
fusain_create_ping_request(&packet);

// Encode to byte buffer
uint8_t tx_buffer[FUSAIN_MAX_PACKET_SIZE * 2];
int len = fusain_encode_packet(&packet, tx_buffer, sizeof(tx_buffer));

if (len > 0) {
    // Send via UART (platform-specific)
    uart_send(tx_buffer, len);
} else {
    // Handle encoding error
    printf("Encoding failed: %d\n", len);
}
```

### Basic Decoding

```c
#include <fusain/fusain.h>

// Decoder state (persistent)
fusain_decoder_t decoder;

// Initialize decoder
fusain_reset_decoder(&decoder);

// Process incoming bytes
while (uart_has_data()) {
    uint8_t byte = uart_read_byte();
    fusain_packet_t packet;

    fusain_decode_result_t result = fusain_decode_byte(byte, &packet, &decoder);

    if (result == FUSAIN_DECODE_OK) {
        // Packet complete and valid
        printf("Received message type: 0x%02X\n", packet.msg_type);
        process_packet(&packet);
    } else if (result != FUSAIN_DECODE_INCOMPLETE) {
        // Decode error - reset and continue
        printf("Decode error: %d\n", result);
        fusain_reset_decoder(&decoder);
    }
}
```

### Creating State Data

```c
#include <fusain/fusain.h>

// Create state data response
fusain_packet_t packet;
uint64_t device_address = 0x0123456789ABCDEF;

fusain_create_state_data(&packet, device_address,
    0,                       // no error
    FUSAIN_ERROR_NONE,       // error code
    FUSAIN_STATE_HEATING,    // current state
    12345                    // timestamp (ms since boot)
);

// Encode and send
uint8_t tx_buffer[FUSAIN_MAX_PACKET_SIZE * 2];
int len = fusain_encode_packet(&packet, tx_buffer, sizeof(tx_buffer));
if (len > 0) {
    uart_send(tx_buffer, len);
}
```

---

## Integration Guide

The library supports dual-mode builds: as a Zephyr module or as a standalone CMake library.

### Zephyr Integration (Embedded)

**1. Add module to application CMakeLists.txt:**

```cmake
# Add fusain module
list(APPEND EXTRA_ZEPHYR_MODULES ${CMAKE_CURRENT_SOURCE_DIR}/../../modules/lib/fusain)

find_package(Zephyr REQUIRED HINTS $ENV{ZEPHYR_BASE})
```

**2. Enable in prj.conf:**

```kconfig
CONFIG_FUSAIN=y
```

**3. Include header:**

```c
#include <fusain/fusain.h>
```

### Standalone CMake Integration (Desktop/Other Platforms)

The library can be built and used without Zephyr. The CMakeLists.txt automatically detects the build mode based on `ZEPHYR_BASE`.

**Option 1: Using find_package (after installation)**

```bash
# Build and install
cmake -B build
cmake --build build
cmake --install build --prefix /usr/local
```

```cmake
# In your CMakeLists.txt
find_package(fusain REQUIRED)
target_link_libraries(myapp PRIVATE Fusain::fusain)
```

**Option 2: Add as subdirectory**

```cmake
add_subdirectory(path/to/fusain)
target_link_libraries(myapp PRIVATE Fusain::fusain)
```

**Option 3: Direct source inclusion**

```cmake
target_sources(myapp PRIVATE
    path/to/fusain/src/fusain.c
)

target_include_directories(myapp PRIVATE
    path/to/fusain/include
)
```

**Include header:**

```c
#include <fusain/fusain.h>
```

**No additional dependencies required** - uses only standard C library

---

## Configuration (Zephyr)

### Kconfig Options

**CONFIG_FUSAIN** (bool)
- Enable the Fusain protocol library
- Default: n

**CONFIG_FUSAIN_LOG_LEVEL** (int)
- Log level for the protocol library
- Range: 0-4 (0=OFF, 1=ERROR, 2=WARNING, 3=INFO, 4=DEBUG)
- Default: 3

**Note:** The protocol library itself has no dependencies on CONFIG_CRC or CONFIG_SERIAL. It implements its own CRC and is protocol-only (no UART code).

---

## Thread Safety

### Encoder Functions
- **Thread-safe:** `fusain_encode_packet()`, `fusain_crc16()`, all `fusain_create_*()` helpers
- **Reason:** Stateless, pure functions

### Decoder Functions
- **NOT thread-safe:** `fusain_decode_byte()`
- **Reason:** Requires maintained state across calls
- **Solution:** Use separate decoder state per connection, or protect with mutex

### Reset Function
- **Thread-safe:** `fusain_reset_decoder()`
- **Reason:** Simple state initialization

---

## Performance Characteristics

### Memory Usage

**Static (per module):**
- Code size: ~1.5 KB
- No global variables

**Dynamic (per connection):**
- Encoder: 0 bytes (stateless)
- Decoder state: state + buffer + flags
  - `uint8_t state`
  - `uint8_t buffer[FUSAIN_MAX_PACKET_SIZE]`
  - `size_t buffer_index`
  - `bool escape_next`

### Computational Complexity

- **CRC calculation:** O(n) where n = payload length
- **Encoding:** O(n) where n = payload length (worst case: 2n with byte stuffing)
- **Decoding:** O(1) per byte received

### Timing

On Cortex-M33 @ 150MHz (typical):
- CRC-16 calculation: ~5 µs per max payload
- Encoding: ~8 µs per max payload
- Decoding: ~2 µs per byte

---

## Testing

### Test Infrastructure

The library has two test modes:

1. **Zephyr Tests (Twister)** - Full integration with Zephyr test framework
2. **Standalone Tests** - Pure C tests that run without Zephyr

The test sources in `tests/src/` use ztest macros. The standalone test infrastructure in `tests/standalone/` provides a ztest compatibility layer, allowing the same test code to run in both environments.

### Taskfile Commands

**Zephyr Tests:**
```bash
task test              # Run all tests with Twister
task test-functional   # Run functional tests only
task test-fuzz         # Run fuzz tests only
task test -- 5000      # Run with custom fuzz round count
task ci                # Full CI: format check + 5M fuzz rounds
```

**Standalone Tests:**
```bash
task standalone-build         # Build library only
task standalone-build-tests   # Build with tests
task standalone-test          # Run tests via CTest
task standalone-test-verbose  # Run with detailed output
task standalone-fuzz          # Run standalone fuzz tests (default: 1M rounds)
task standalone-fuzz -- 5000  # Run with custom fuzz round count
task standalone-coverage      # Run with gcovr coverage report
task standalone-ci            # Format check + tests + fuzz (1M rounds)
task standalone-clean         # Clean build artifacts
```

**CI Tasks:**
```bash
task standalone-ci   # Fast: format + standalone tests + 1M fuzz (no Zephyr required)
task ci              # Full: format + standalone + Zephyr tests + 5M fuzz rounds
task ci-in-docker    # Full CI in Zephyr Docker container (auto-cleans build artifacts)
```

Use `standalone-ci` for fast local validation during development. Use `ci` or `ci-in-docker` for full validation before commits. The `ci-in-docker` task mirrors the GitHub Actions workflow and automatically cleans up build artifacts after completion.

### Git Hooks

Install the pre-commit hook to automatically validate changes before each commit:

```bash
task install-git-hooks
```

**What the hook runs:**
1. `task format-check` - Fast formatting validation
2. `task ci` - Full test suite (format + standalone + Zephyr + 5M fuzz rounds)

**Skip hook:** `git commit --no-verify` (use sparingly)

**Uninstall:** `rm .git/hooks/pre-commit`

### GitHub Actions CI

The library includes a GitHub Actions workflow (`.github/workflows/ci.yml`) that runs the full test suite using a custom Docker image built from the repository's `Dockerfile`.

**Triggered on:** Push/PR to `master` branch

**What it runs:**
1. Format check (clang-format)
2. Standalone tests with 100% coverage verification
3. Standalone fuzz tests (1M rounds)
4. Zephyr tests with coverage verification
5. Zephyr fuzz tests (5M rounds)

**Local reproduction:**
```bash
task ci-in-docker
```

This runs the same `task ci` command in the same Docker image used by GitHub Actions, ensuring local and CI environments match.

**Version pinning:**
- Zephyr SDK version is pinned in `.zephyr-sdk-version`
- Zephyr version is pinned in `west.yml` (currently v4.3.0)

**Docker layer caching:** GitHub Actions caches Docker image layers for faster CI runs.

### Coverage

Standalone tests achieve **100% code coverage** on `src/fusain.c`.

```bash
task standalone-coverage
```

Output:
```
File                Lines    Exec  Cover
src/fusain.c          254     254   100%
```

Requires `gcovr` (`pip install gcovr`).

### Unit Testing

The module has been tested with:
- **Platform:** Raspberry Pi Pico 2 (RP2350A, Cortex-M33)
- **RTOS:** Zephyr RTOS v4.3.0+
- **UART:** 115200 baud
- **Duration:** Extended burn testing (Helios ICU firmware)

### Test Scenarios

1. **Round-trip encoding/decoding**
   - All message types
   - Various payload sizes (0 to max)
   - Edge cases (empty payloads, maximum payloads)

2. **Byte stuffing**
   - Payloads containing START/END/ESC bytes
   - Consecutive escape sequences
   - Escape sequences at payload boundaries

3. **Error handling**
   - Invalid CRC
   - Invalid length
   - Truncated packets
   - Garbage data
   - Mid-packet corruption

4. **Performance**
   - Sustained 100ms telemetry broadcast rate
   - Concurrent command reception
   - No memory leaks or buffer overflows

### Integration Testing

Tested in production use:
- **Helios ICU firmware** - UART slave, telemetry broadcasting, command processing
- **Communication reliability** - Extended operation without errors
- **Timeout mode** - Automatic IDLE transition on communication loss

---

## Common Patterns

### Master Implementation (Controller)

```c
// Send commands periodically
void send_ping(uint64_t device_address) {
    fusain_packet_t packet;
    fusain_create_ping_request(&packet, device_address);

    uint8_t tx_buffer[FUSAIN_MAX_PACKET_SIZE * 2];
    int len = fusain_encode_packet(&packet, tx_buffer, sizeof(tx_buffer));
    uart_send(tx_buffer, len);
}

// Process received telemetry
void process_telemetry(const fusain_packet_t* packet) {
    switch (packet->msg_type) {
        case FUSAIN_MSG_STATE_DATA: {
            fusain_data_state_t* state = (fusain_data_state_t*)packet->payload;
            printf("State: %u, Error: %u, Code: %d\n",
                   state->state, state->error, state->code);
            break;
        }
        case FUSAIN_MSG_MOTOR_DATA: {
            fusain_data_motor_t* motor = (fusain_data_motor_t*)packet->payload;
            printf("Motor %d: RPM=%d, Target=%d\n",
                   motor->motor, motor->rpm, motor->target);
            break;
        }
        case FUSAIN_MSG_TEMP_DATA: {
            fusain_data_temperature_t* temp = (fusain_data_temperature_t*)packet->payload;
            printf("Temp %d: %.1f°C\n", temp->thermometer, temp->reading);
            break;
        }
    }
}
```

### Slave Implementation (ICU)

```c
// Process received commands
void process_command(const fusain_packet_t* packet) {
    switch (packet->msg_type) {
        case FUSAIN_MSG_STATE_COMMAND: {
            fusain_cmd_set_mode_t* cmd = (fusain_cmd_set_mode_t*)packet->payload;
            if (cmd->mode == FUSAIN_MODE_EMERGENCY) {
                trigger_emergency_stop();
            } else {
                set_operating_mode(cmd->mode, cmd->argument);
            }
            break;
        }

        case FUSAIN_MSG_PING_REQUEST: {
            // Respond with uptime
            fusain_packet_t response;
            fusain_create_ping_response(&response, packet->address, get_uptime_ms());
            send_packet(&response);
            break;
        }

        case FUSAIN_MSG_MOTOR_COMMAND: {
            fusain_cmd_set_target_rpm_t* cmd = (fusain_cmd_set_target_rpm_t*)packet->payload;
            set_motor_rpm(cmd->motor, cmd->rpm);
            break;
        }
    }
}
```

---

## Troubleshooting

### Common Issues

**1. Include path not found**
- **Symptom:** `fatal error: fusain/fusain.h: No such file or directory`
- **Solution:** Ensure module include directory is added to build system
  - Zephyr: Verify `CONFIG_FUSAIN=y` and `EXTRA_ZEPHYR_MODULES` is set
  - Standalone: Verify `target_include_directories()` includes module path

**2. Decoder returns INVALID_CRC**
- **Symptom:** Valid-looking packets rejected with CRC errors
- **Solution:**
  - Ensure both ends use same byte order (little-endian multi-byte values)
  - Verify byte stuffing is applied correctly
  - Check for UART parity/framing errors

**3. Decoder stuck in INCOMPLETE state**
- **Symptom:** Packets never complete, decoder never returns OK
- **Solution:**
  - Check for missing END byte
  - Verify START byte is being detected
  - Reset decoder after timeout period

**4. Buffer overflow during encoding**
- **Symptom:** `fusain_encode_packet()` returns negative error
- **Solution:** Ensure output buffer is at least `FUSAIN_MAX_PACKET_SIZE * 2` bytes

---

## Best Practices

### 1. Buffer Management

```c
// ✅ GOOD - Proper buffer sizing
uint8_t tx_buffer[FUSAIN_MAX_PACKET_SIZE * 2];  // Account for byte stuffing

// ❌ BAD - Insufficient buffer
uint8_t tx_buffer[FUSAIN_MAX_PACKET_SIZE];      // May overflow with stuffing
```

### 2. Error Handling

```c
// ✅ GOOD - Check all return values
int len = fusain_encode_packet(&packet, buffer, sizeof(buffer));
if (len < 0) {
    log_error("Encoding failed: %d", len);
    return;
}

// ❌ BAD - Ignoring errors
fusain_encode_packet(&packet, buffer, sizeof(buffer));
uart_send(buffer, 64);  // Wrong! May send garbage
```

### 3. Decoder State Management

```c
// ✅ GOOD - One decoder per connection
typedef struct {
    uint8_t state;
    uint8_t buffer[FUSAIN_MAX_PACKET_SIZE];
    size_t buffer_index;
    bool escape_next;
} connection_t;

// ❌ BAD - Shared decoder for multiple connections
static uint8_t decoder_state;  // Race conditions!
```

### 4. Reset After Errors

```c
// ✅ GOOD - Reset decoder after errors
if (result != FUSAIN_DECODE_OK && result != FUSAIN_DECODE_INCOMPLETE) {
    log_error("Decode error: %d", result);
    fusain_reset_decoder(&state, &index, &escape);
}

// ❌ BAD - Continue after error
if (result == FUSAIN_DECODE_INVALID_CRC) {
    // Decoder still in invalid state!
}
```

---

## Protocol Extensions

### Adding New Message Types

1. **Define message type in header:**

```c
// In fusain.h
typedef enum {
    // ... existing types ...
    FUSAIN_MSG_NEW_COMMAND = 0x16,
} fusain_msg_type_t;
```

2. **Define payload structure:**

```c
typedef struct __attribute__((packed)) {
    uint32_t field1;
    uint8_t field2;
} fusain_cmd_new_command_t;
```

3. **Create helper function (optional):**

```c
// In fusain.c
void fusain_create_new_command(fusain_packet_t* packet,
                               uint32_t field1,
                               uint8_t field2) {
    fusain_cmd_new_command_t cmd = {
        .field1 = field1,
        .field2 = field2
    };
    packet->length = sizeof(cmd);
    packet->msg_type = FUSAIN_MSG_NEW_COMMAND;
    memcpy(packet->payload, &cmd, sizeof(cmd));
}
```

4. **Update copyright year** if adding to module

---

## References

- **Protocol Specification:** `origin/documentation/source/specifications/fusain/` (canonical Sphinx docs)
- **Reference Implementations:**
  - **C:** This library (`modules/lib/fusain/`) - Embedded C for Zephyr RTOS
  - **Go:** `tools/heliostat/pkg/fusain/` - Reference Go implementation
- **Integration Example:** See `apps/helios/src/communications/serial_handler.c`
- **CRC-16-CCITT:** Polynomial 0x1021, initial value 0xFFFF
- **Byte Stuffing:** Consistent Overhead Byte Stuffing (COBS) variant

---

## License

Apache-2.0

Copyright (c) 2025 Kaz Walker, Thermoquad

Licensed under the Apache License, Version 2.0. See LICENSE.md for full text.

---

## AI Assistant Operations

To reload all organization CLAUDE.md files or run a content integrity check, see the **CLAUDE.md Reload** and **Content Integrity Check** sections in the [Thermoquad Organization CLAUDE.md](../../../CLAUDE.md).

---

**Last Updated:** 2026-01-15

**Maintainer:** Kaz Walker
